<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Tutorial: Introduction</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><link href="../styles/jamoma.css" rel="stylesheet" type="text/css"></head><body><div id="jmod_header">	<img src="../images/jmod.icon.mod.png" width="128" height="128">	  <h1>using jamoma - tutorial one </h1>  <h2>a stereo effect module</h2>	<h6><a href="../index.html">Table of Contents</a> | <a href="../modules/">Index of Modules</a> | <a href="http://jamoma.org/">Jamoma.org</a></h6></div><h3>Loading a module</h3><p>Jamoma consist of a number of modules for processing of control data, audio   and video. Each module behaves like an object in Max. Compared to ordinary Max   objects Jamoma modules offers higher level functionalities, with more complex   behaviour, and a user interface for interaction. Jamoma modules are saved as   <em>abstractions</em>. You can find more inforation on abstractions and the   bpatcher object in Max tutorials 26-28 and 43. In this tutorial we will use   one Jamoma module, and play around with it to see what functionalities are embeded   in a module. Before starting, pelase make sure that Jamoma is properly installed   in the Max search path as described in <a href="../../../ReadMe.html">here</a>.</p><p>We will be using a module named <strong>jmod.echo~.mod</strong>. This is a   simple stereo audio effect, offering stereo echos with filtering and feedback.   This can either be loaded as an ordinary object or a bpatcher.</p><h4>Loading a module as object</h4><p>If you want to load it as an ordinary object, follow these steps:</p><ol>  <li>Create a new empty Max patch</li>  <li>Create a new object box, and type in <strong>jmod.edge~.mod</strong>. This     should create an object with three inlets and three outlets.</li>  <li>If you double-click the object, a small window will open, offering an interface     for the object.</li></ol><p><img src="../images/using_01_object.png" width="305" height="188"></p><h4>Loading a module as bpatcher</h4><p>If we instead want to embedd the interface in the patch, we can load it as   a bpatcher:</p><ol>  <li>Create a new empty Max patch</li>  <li>Create a new bpatcher object.</li>  <li>Open the inspector, and set Patcher File to <strong>jmod.echo~.mod</strong>.</li>  <li>You should see the module displayed, and the bpatcher window resized to     proper dimention.</li>  <li>Close the bpatcher inspector. No other settings need to be made.</li></ol><p><img src="../images/using_01_bpatcher.png" width="350" height="431"></p><h4>Naming and initialising the module</h4><p>Before we start playing around with the module, we have to name and initialise   it. Give the object a name by selecting it, choose <strong>Object &gt; Name...</strong>   from the menu, and type in a name. The object need an OpenSoundControl name,   so it should start with a slash. Later on, as we add more modules, the name   becomes important, as it is used to distinguish one module from another. <strong>/echo~</strong>   seems a good name for our module.</p><p>Jamoma use a special system for initialisation, instead of relying on loadbang.   We have to initialise the modules by sending a bang to jmod.init. Here are two   ways of doing it, using either a message box or ubutton and send:</p><p><img src="../images/using_01_initialisation.png" width="294" height="185"></p><p>If everything worked as supposed to, the module should look as above. Notice   that the name we provided, now is displayed in the upper left corner of the   module. </p><h4>Playing around with the module</h4><p>Jamoma modules might have a varying number of inlets and outlets. The leftmost   inlet and outlet is always used for control messages to and from the object.   The remaining inlets and outlets are optional and used for signals. jmod.echo~.mod   is a stereo effect, and therefore have two signal inlets and outlets. All in   all it have three inlets and outlets.</p><p>Now we will add a few more objects to the patch so that we can start exploring   the module:</p><p><img src="../images/using_01_first-test.png" width="374" height="369"></p><p>This way we can open a stereo sound file, play and loop it, and listen to the   resulting sound. Open a sound file, and turn on audio.</p><p>Initially, the echo effect is muted, and gain is turned all way down. At the   top of the module there is a toolbar that is common to most audio modules. The   M button mutes and umute the module. The egg slider is used for adjusting volume.   You can monitor volume out of the module as well.</p><p>Once you have sound going, you can start playing wiht the parameters of the   module. You can change delay time in millisceconds of the left and right channel   delays, feedback, what kind of filter to use, and filter gain, frequency and   resonance.</p><p>In the toolbar, there are a few more settings to explore. The B button can   be used for bypassing the module. The dial set the mix between dry and wet signal.   If it is all blue, you only get the wet signal. If it is all gray, you only   get the dry signal. The effect of muting and bypassing might be easiest to hear   by turning setting mix to all wet or all dry respectively.</p><p>You can change internal sampling rate in the echo effect by clicking the arrows   at the right of the toolbar. You will have to restart audio for this to take   effect. If you use an effect that takes a lot of CPU, and you know that it will   not produce a lot of high freqiuency output, you can reduce the CPU load by   downsampling the module.</p><h4>Control messages to and from the module</h4><p>Next we want to communicate messages to and from the module. We will start   of by connecting the left outlet to a <strong>print</strong> object and watch   the Max window as we change parameters. Whenever we change a parameter, an OpenSoundControl   message is output with the new value. Here are some examples:</p><blockquote>  <p class="instruction">/left 250 <br>    /right 750 <br>    /feedback 0.33<br>    /gain/midi 102.000000 <br>    /filtergain -1.780200 <br>    /cf 1773.715454 <br>    /q 0.662400 <br>    /filtergain 1.918100 <br>    /filtertype lowpass </p></blockquote><p>We can send similar messages to the leftmost inlet of the module. This could   be used for instance to adjust delays depending on the tempo:</p><p><img src="../images/using_01_messages.png" width="371" height="391"></p><p>The module also have built in possibility for parameters to ramp to new values   over time. Suppose that we want to introduce delay feedback gradually. This   can be done by adding a second argument to the /feedback message, specifying   how long it shoudl take to ramp from current to the new value:</p><p><img src="../images/using_01_ramping.png" width="282" height="287"></p><h4>Controlling gain</h4><p>Gain can be controlled in several ways in most Jamoma modules, depending on   your need:</p><table width="90%" border="0">  <tr>     <td width="13%" class="instructionName">/gain</td>    <td width="87%" class="instructionDescription">set gain value in dB</td>  </tr>  <tr>     <td class="instructionName">/gain/midi</td>    <td class="instructionDescription">set gain as MIDI value</td>  </tr>  <tr>     <td class="instructionName">/gain/inc</td>    <td class="instructionDescription">increase MIDI value by one</td>  </tr>  <tr>     <td class="instructionName">/gain/dec</td>    <td class="instructionDescription">decrease MIDI value by one.</td>  </tr></table><p>Here is a patch illustrating how this work. Note that regardless of how you   change the gain, the new gain value is output from the left outlet as MIDI value.</p><p><img src="../images/using_01_gain.png" width="280" height="413"> </p><h4>The module pop-up menu</h4><p>&nbsp;</p></body></html>