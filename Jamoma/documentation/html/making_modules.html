<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
		<meta name="generator" content="Adobe GoLive 6">
		<title>Making Your Own Audio Module: A Recipe</title>
	</head>

	<body bgcolor="#ffffff">
		<h3>Ingredients</h3>
		<ul>
			<li>jmod.gui (bpatcher)
			<li>jmod.hub
			<li>jmod.parameter(s)
			<li>poly~
			<li>pattrstorage
		</ul>
		<h3>Step 1: Develop an algorithm</h3>
		<p>Audio modules will typically have the actual audio calculations encapsulated in MSP's poly~ object. The poly~ object loads a patcher into itself and then provides a number of services for that patch.  These services include muting, downsampling, and polyphonic voice management.  In Jamoma, we refer to the patch that you will load into the poly~ as your module's algorithm.</p>
		<p>Your algorithm will need inlets and outlets for each audio signal that it will send and receive. The first inlet should double as a way to get control messages into the module.  These control messages will consist of a parameter name followed by one or more arguments.  You can use Max's standard route object to strip off the paramater name and get the actual incoming values from that parameter.  </p>
		<p>To adhere to the Jamoma Guidelines, this patch should be saved in text format and have an extension of &quot;.alg&quot;.</p>
		<h3>Step 2: Assemble your module</h3>
		<p>The audio module itself will be a Max patch, also saved in text format but with an extension of &quot;.mod&quot;.  Create the new patcher, and then follow these steps:</p>
		<ol>
			<li>Create an inlet for control input, and additional inlet(s) for audio signals.
			<li>Create an outlet for control output, and additional outlet(s) for audio signals.
			<li>Instantiate a jmod.hub object.  The first argument must be #0_ and the second argument should be the name of the module (without the file extension).  Connect the first inlet to the left-most inlet object in your patch.  Connect the first outlet to the left-most outlet object in your patch.
			<li>Instantiate a bpatcher object. Load the jmod.gui patch that most closely matches your needs in both terms of UI size and the number of audio channels. Give this bpatcher an argument of #0_. Connect the last outlet(s) of this bpatcher object to the last outlet object(s) in your patcher.  Connect the second inlet to the second inlet object in your patch, etc.
			<li>Instantiate a jmod.parameter object for each parameter that you enabled your algorithm patch to receive.  Connect these to ui widgets (i.e. number boxes or sliders) in the same way you would use the pp object for creating plugins.
			<li>Instantiate a poly~ object with the name of your algorithm patch as an argument.  Connect the first outlet(s) of the jmod.gui to the inlet(s) of the poly~.  Connect the second outlet of the jmod.hub to the first inlet of the poly~.  Connect the outlet(s) of the poly~ to the last inlet(s) of the jmod.gui.
			<li>Instantiate a pattrstorage object.  Connect it to the last inlet and outlet of the jmod.hub.
		</ol>
		<p> It is probably helpful to be looking at a simple module such as the degrade~ module as a template.</p>
		<h3>Step 3: Create default preset</h3>
		<p>You should do this.  More coming soon...</p>
		<h3>Step 4: Write the documentation</h3>
		<p>Write an HTML file names as your module's name (the arg to the jmod.hub) with a .html extension.</p>
		<p></p>
	</body>

</html>