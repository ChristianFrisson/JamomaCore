% -----------------------------------------------
% Template for ICMC 2005
%     icmc.sty -> style file
% By Eloi Batlle (eloi@iua.upf.es), changes for 
% ICMC 2005 by Bram de Jong 
% Adapted for the ICMC 2008 by Maarten van Walstijn
% -----------------------------------------------

\documentclass{article}
\usepackage{icmc,amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\definecolor{black}{rgb}{0,0,0}
\hypersetup{colorlinks
,linkcolor=black
,filecolor=black
,urlcolor=black
,citecolor=black}
%reduces the space between the items in the itemize-environment 
\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

% Title.
% ------
\title{Using Dynamically-Bound Structures to Manage Parameter Properties in Jamoma}

% Single address
% To use with only one author or several with the same address
% ---------------
%\oneauthor
%  {Author} {School \\ Department}

% Two addresses
% --------------
%\twoauthors
%  {First author} {School \\ Department}
%  {Second author} {Company \\ Address}

% Three addresses
% --------------
\threeauthors
  {First author} {School \\ Department}
  {Second author} {Company \\ Address}
  {Third author} {Company \\ Address}

\begin{document}
%
\maketitle
%
\begin{abstract}
%The abstract should be placed at the top left column and should contain
%about 150-200 words.

Fundamental to the development of musical or artistic material is the ability to transform raw materials.  This ability implies the facility to master many facets of the material, and to manipulate it with plasticity.  Computer music environments typically provide points of control to manipulate material by providing parameters with controllable values.  It is the experience of the authors that this capability to control the values of parameters is inadequate for many artistic endeavors and does not reflect the analogous tools and methods of artists working with physical materials.  

A possible partial solution to this problem is to treat a parameter not as a single-value representing entity, but to treat a parameter as a multi-dimensional tool or object.  Thus the parameter, as a tool or object, has many facets itself in addition to the value it renders.  These many \emph{properties} of the parameter define its behavior.  The authors have explored a prototype of these ideas in Jamoma, a modular framework for Max/MSP/Jitter.  In addition to defining behaviors, the behaviors are themselves interdependent upon each other requiring a flexible and dynamically bound code base for the implementation.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} % (fold)
\label{sec:introduction}

Jamoma is a Model-View-Controller\footnote{\url{http://en.wikipedia.org/wiki/Model-view-controller}} framework that provides a modular structure for the Max\footnote{\url{http://www.cycling74.com/products/maxmsp}} environment \cite{Place:2006}.  To be effective, it must use a messaging model that is dynamic, flexible, and efficient. The messaging model in Jamoma addresses modules using parameters (nodes with state) and messages (nodes which are stateless). For the duration of this paper we will often refer only to parameters, but the concepts generally apply to both parameters and messages.

In addition to providing values to parameters, each node may also have its behavior defined or modified in real-time through the use of properties and methods \cite{Place:2008}.  These properties define the behavior for parameters by setting a value range, repetition filtering, the type of units used to express values, and how automation is applied.  Following is a list of the properties and methods of a parameter.

\begin{tabular}{ll}
	\texttt{:/value} & The value of the parameter. \\
	\texttt{:/value/stepsize} & The size of the step taken by the inc and dec messages. \\
	\texttt{:/value/inc} & Increase the value of the parameter by the stepsize. \\
	\texttt{:/value/dec} & Decrease the value of the parameter by the stepsize. \\
	\texttt{:/value/default} & The initial value of a parameter when the module is first created. \\
	\texttt{:/type} & The type of data represented by the parameter. \\
	\texttt{:/priority} & The value of the parameter. \\
	\texttt{:/ui/freeze} & The value of the parameter. \\
	\texttt{:/ui/refresh} & The value of the parameter. \\
	\texttt{:/ramp/drive} & The value of the parameter. \\
	\texttt{:/ramp/function} & The value of the parameter. \\
	\texttt{:/repetitions} & The value of the parameter. \\
	\texttt{:/range/bounds} & The value of the parameter. \\
	\texttt{:/range/clip} & The value of the parameter. \\
	\texttt{:/description} & The value of the parameter. \\
	\texttt{:/node/type} & The value of the parameter. \\
	\texttt{:/node/name} & The value of the parameter. \\
	\texttt{:/dataspace} & The value of the parameter. \\
	\texttt{:/dataspace/unit/active} & The value of the parameter. \\
	\texttt{:/dataspace/unit/native} & The value of the parameter. \\
\end{tabular}
% section introduction (end)

\section{Dynamic Binding in Jamoma}

\subsection{The Subscription System}

Parameters are bound dynamically to a module.  When a Max patcher loads a module, that module creates a \emph{hub} object which acts as the controller for everything in the module.  Then as parameters are created they subscribe to the hub to form a bi-directional connection for exchanging data.  The existence of parameters may even change through the use of scripting over the course of time, and in response to changes in other parameters.

\subsection{Parameter Components}

In Jamoma, the parameter is implemented as a Max external called \emph{jcom.parameter}.  Within this jcom.parameter the ramp and dataspace properties are implemented internally as dynamically bound objects using the TTBlue framework\footnote{\url{http://www.electrotap.com/ttblue/}}.  The TTBlue framework is a C++ library that implements a dynamic messaging layer rather than using statically-linked C/C++ function calls \cite{Place:2008ttblue}.  

By using dynamically linked components inside of the parameter, it is possible to switch between many different options for a give parameter property, while each option may implement an entirely different set of methods.  This will be demonstrated in upcoming sections.

\subsection{The Jamoma ``Libs''}

The functionality we refer to within a parameter is implemented in a shared library. Within the shared library the different functionalities are grouped in a series of ``Libs''.  These libraries provide the key functionalities for developing multidimensional tools.  To date, the libs are composed of:
\begin{itemize}
	\item FunctionLib: a library of FunctionUnits which map an input value to an output value
	\item RampLib: a library of driving mechanisms (RampUnits) which use the FunctionLib to automate value transformations over time.
	\item DataspaceLib: a library by which a parameter or message can be given a class that describes the type of data it represents.  Values may then be set by any of a number of DataspaceUnits to allow control of a parameter in any of a number of ways.
\end{itemize}



\section{FunctionLib}\label{sec:functionlib}

The Jamoma FunctionLib API provides normalized mappings of values $x \in [0,1]$ to $y \in [0,1]$ according to functions $y = f(x)$. The FunctionLib can easily be expanded by introducing new functions in the form of two C++ files: a source file and a header file that provides an interface for the source file.

Currently five functions are implemented: 

\begin{itemize}
	\item Linear: $y = x$.
	\item Cosine: $y = - \frac{1}{2} * cos(x * \pi ) + \frac{1}{2} $.
	\item Lowpass series: $y[n] = y[n-1] * k + x[n] * (1-k)$, \\ where $k$ is a feedback coefficient.
	\item Power function: $ y = x^{k} $, where the parameter $k$ can be set.
	\item Hyperbolic tangent: $ y = c * (tanh(a*(x-b)) - d) $, \\ where coefficients $a$, $b$, $c$, $d$ depends on the width and offset of the curve.
\end{itemize}

There are plans to introduce exponential functions.



\section{RampLib}\label{sec:ramplib}

Jamoma offers vastly extended possibilities in how ramping can be done as compared to Max. In Jamoma the process of ramping is made up from the combination of two components: A driving mechanism cause calculations of new values at desired intervals during the ramp, while a set of functions offers a set of curves for the ramping. Both components are implemented as C++ APIs, and can easily be extended with new ramp or function \emph{units}, expanding the range of possible ramping modes.

The Jamoma RampLib API provides a means by which to create and use \emph{ramp units} in Jamoma.  A ramp unit is a self-contained algorithm that can slide from an existing value to a new value over a specified amount of time according to different timing mechanisms. Each ramp unit is implemented in the form of two C++ files: a source file and a header file that provides an interface for the source file. Currently four such ramp units are implemented:

\begin{itemize}
	\item \emph{none} - jumps immediately to the new value. Typically used for values where ramping do not make sense.
	\item \emph{scheduler} - use the Max internal clock to generate new values at fixed time intervals.
	\item \emph{queue} - ramping using the Max queue, updating values whenever the processor has free capacity to do so.
	\item \emph{async} - only calculate new values when requested to do so. This might be used in video processing modules to calculate fresh values immediately before processing the next video image or matrix.
\end{itemize}

When a new ramp is started, the ramp unit internally use a normalized ramping value, increasing linearly from $0.0$ to $1.0$ over the duration of the ramp. Whenever the ramp unit is to provide a new value, it updates the normalized ramping value, and pass it to a Function Unit as described in Section~\ref{ssub:the_function_lib}. The normalized value returned is then scaled to the range defined by the start and end values for the ramp, and passed on to the module.



\section{DataspaceLib}\label{sec:dataspacelib}

It will be good for us to try and explain all the interactions here ;-)

\subsection{TemperatureDataspace}\label{subsec:temperature_dataspace}

La de da...



\section{Interdependencies}\label{sec:interdependencies}

This paper discusses the structure and development of the interrelated libraries that are used to implement this system.



%%%%%%%%%%%%%%%%%%%%%%
% TODO: This may have no place here, who knows...  We cut it from the NIME paper [TAP]
\subsection{Controlling the User Interface} % (fold)
\label{sub:controlling_the_user_interface}

In certain applications the CPU overhead of continuously updating the graphical user interface whenever parameter or message values change might become a burden, competing for CPU with e.g. video processing algorithms. If the user does not need continuous visual feedback on updated values of parameters or messages, the GUI for the parameter or message can be frozen, freeing up the processor and GPU for tasks considered more important:

\texttt{:/ui/freeze}

\texttt{:/ui/freeze/get}

A parameter or message that has its GUI frozen can be forced to update and refresh the displayed value once by means of the message:

\texttt{:/ui/refresh}

% subsection controlling_the_user_interface (end)



%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion and further work} % (fold)
\label{sec:discussion_and_further_work}

4 ramp units times 5 function units = 20 ramping modes

ramp units can be used for other scheduled processes as well

Possibility of expanding ramp units as low frequency oscillators

function units can be used elsewhere, e.g. for mapping

Audio rate ramp unit.

DataspaceLib

Querying - we propose a different system to the Lemur OSC2 draft

Ramp Lib and Function Lib can be used outside the context of jcom.parameter and jcom.value: jcom.map and jcom.ramp



% section discussion_and_further_work (end)

\cite{Momeni:2003}



\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
          & Cosine & Linear & Lowpass & Power & Tanh \\
\hline
Scheduler &        &   x    &         &       & \\
\hline
Queue	  &        &        &         &       & \\
\hline
None	  &        &        &         &       & \\
\hline
Async	  &        &        &         &       & \\
\hline
\end{tabular}
\end{center}
\caption{Table captions should be placed below the table}
\label{tab:example}
\end{table}




%\begin{thebibliography}{citations}
%
%\bibitem{Author:00} Author, E.
%''The title of the conference paper'',
%{\it Proceedings of the International Computer Music Conference}, Miami, USA, 2004.
%
%\bibitem{Someone:02} Someone, A.
%{\it  Title of the book}.
%Publisher, Belfast, 2007.
%
%\end{thebibliography}

% Bibliography (fold)
%
% The following two commands are all you need in the initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
% CHANGED: I remove the small again for the bibliography, since this isn't used in the template.
%\begin{small}
\bibliographystyle{abbrv}
\bibliography{jamoma-icmc2008}  % the name of the Bibliography in this case
%\end{small}
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% Bibliography (end)



\end{document}
